from flask import Flask, request, send_from_directory, render_template, jsonify
from PIL import Image
import os
import pillow_heif  # Required for HEIC support

# Initialize Flask app
app = Flask(__name__)

# Define paths for uploads, watermarked outputs, and logo
UPLOAD_FOLDER = 'Uploads'  # Storage for staged (pre-watermarked) images
WATERMARKED_FOLDER = 'watermarked'  # Storage for watermarked images
LOGO_PATH = 'logo.png'  # Update if logo is named differently (e.g., 'dance_logo.png')
ALLOWED_EXTENSIONS = {'jpg', 'jpeg', 'png', 'heic', 'heif'}  # Added HEIC/HEIF support

# Create folders if they don't exist
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(WATERMARKED_FOLDER, exist_ok=True)

# Register HEIC/HEIF support with Pillow
pillow_heif.register_heif_opener()

# Check if uploaded file has an allowed extension
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Function to add watermark to an image
def add_watermark(image_path, output_path):
    # Open the uploaded image and logo
    base_image = Image.open(image_path)
    watermark = Image.open(LOGO_PATH).convert("RGBA")  # Convert logo to RGBA for transparency
    
    # Resize watermark to 20% of base image width (adjustable)
    watermark_width = int(base_image.width * 0.2)
    watermark_height = int(watermark_width * (watermark.height / watermark.width))
    watermark = watermark.resize((watermark_width, watermark_height), Image.Resampling.LANCZOS)
    
    # Position watermark in bottom-right corner with 20px padding (adjustable)
    position = (base_image.width - watermark_width - 20, base_image.height - watermark_height - 20)
    
    # Convert base image to RGBA if needed for transparency support
    if base_image.mode != 'RGBA':
        base_image = base_image.convert('RGBA')
    
    # Overlay watermark
    base_image.paste(watermark, position, watermark)  # Use watermark as mask for transparency
    
    # Convert to RGB for output (output as JPEG for consistency)
    base_image = base_image.convert('RGB')
    
    # Save as JPEG (regardless of input format) to ensure compatibility
    output_path = os.path.splitext(output_path)[0] + '.jpg'
    base_image.save(output_path, quality=95)  # Save with high quality

# Route to stage files
@app.route('/stage', methods=['POST'])
def stage_files():
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': 'No file part'}), 400
    
    files = request.files.getlist('file')
    if not files or all(file.filename == '' for file in files):
        return jsonify({'success': False, 'error': 'No selected files'}), 400
    
    for file in files:
        if file and allowed_file(file.filename):
            filename = file.filename
            input_path = os.path.join(UPLOAD_FOLDER, filename)
            try:
                file.save(input_path)
            except Exception as e:
                return jsonify({'success': False, 'error': f'Error staging {filename}: {str(e)}'}), 500
    
    return jsonify({'success': True}), 200

# Route for the main page
@app.route('/', methods=['GET'])
def main_page():
    # Get list of pre-watermarked (staged) files
    original_files = [f for f in os.listdir(UPLOAD_FOLDER) if allowed_file(f)]
    
    # Get list of watermarked files
    watermarked_files = [f for f in os.listdir(WATERMARKED_FOLDER) if allowed_file(f)]
    
    # Render HTML template
    return render_template('index.html', original_files=original_files, watermarked_files=watermarked_files)

# Route to process all staged files
@app.route('/process', methods=['POST'])
def process_files():
    original_files = [f for f in os.listdir(UPLOAD_FOLDER) if allowed_file(f)]
    if not original_files:
        return jsonify({'success': False, 'error': 'No files to process'}), 400
    
    download_links = []
    for filename in original_files:
        input_path = os.path.join(UPLOAD_FOLDER, filename)
        output_filename = f"watermarked_{filename.rsplit('.', 1)[0]}.jpg"  # Output as JPEG
        output_path = os.path.join(WATERMARKED_FOLDER, output_filename)
        
        try:
            add_watermark(input_path, output_path)
            os.remove(input_path)  # Delete original after successful watermarking
            download_links.append({'filename': output_filename, 'url': f'/download/{output_filename}'})
        except Exception as e:
            return jsonify({'success': False, 'error': f'Error processing {filename}: {str(e)}'}), 500
    
    return jsonify({'success': True, 'links': download_links}), 200

# Route to serve watermarked files for download
@app.route('/download/<filename>')
def download_file(filename):
    return send_from_directory(WATERMARKED_FOLDER, filename, as_attachment=True)

# Route to delete a watermarked file
@app.route('/delete/<filename>', methods=['GET'])
def delete_file(filename):
    file_path = os.path.join(WATERMARKED_FOLDER, filename)
    if os.path.exists(file_path) and allowed_file(filename):
        try:
            os.remove(file_path)
            return jsonify({'success': True}), 200
        except Exception as e:
            return jsonify({'success': False, 'error': f'Error deleting {filename}: {str(e)}'}), 500
    return jsonify({'success': False, 'error': 'File not found'}), 404

# Route to serve pre-watermarked (staged) files for download
@app.route('/download_original/<filename>')
def download_original_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=True)

# Route to delete a pre-watermarked (staged) file
@app.route('/delete_original/<filename>', methods=['GET'])
def delete_original_file(filename):
    file_path = os.path.join(UPLOAD_FOLDER, filename)
    if os.path.exists(file_path) and allowed_file(filename):
        try:
            os.remove(file_path)
            return jsonify({'success': True}), 200
        except Exception as e:
            return jsonify({'success': False, 'error': f'Error deleting {filename}: {str(e)}'}), 500
    return jsonify({'success': False, 'error': 'File not found'}), 404

# Run the server on all interfaces, port 5000, with debug mode
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)